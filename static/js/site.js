// Generated by CoffeeScript 1.6.3
(function() {
  var expect, expectChord, expectKey, initInstrument, log, makePromise, _ref,
    __slice = [].slice;

  window._d = window.d = (_ref = typeof console !== "undefined" && console !== null ? console.log.bind(console) : void 0) != null ? _ref : function() {};

  log = function() {
    var text, texts, _i, _len, _results;
    texts = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    _results = [];
    for (_i = 0, _len = texts.length; _i < _len; _i++) {
      text = texts[_i];
      _results.push(d3.select('#log').append('p', ':first-child').text(text));
    }
    return _results;
  };

  makePromise = function(fn) {
    var defer;
    defer = Q.defer();
    fn(defer);
    return defer.promise;
  };

  expectKey = function(k) {
    return makePromise(function(defer) {
      return key(k, function() {
        d('Key pressed!');
        key.unbind(k);
        return defer.resolve();
      });
    });
  };

  expectChord = function(ks) {
    return makePromise(function(defer) {
      var k, n, _i, _len;
      n = ks.length;
      for (_i = 0, _len = ks.length; _i < _len; _i++) {
        k = ks[_i];
        expectKey(k).then(function() {
          d(1);
          if (--n === 0) {
            return defer.resolve();
          }
        });
      }
    });
  };

  expect = function(ks) {
    d('expecting', ks);
    return function() {
      return expectChord(ks.split(''));
    };
  };

  key('a', function() {
    return d('a');
  });

  initInstrument = function() {
    var dispatch, nextId, untilTrue;
    dispatch = d3.dispatch('ready', 'keydown', 'keyup', 'error');
    navigator.requestMIDIAccess().then(function(midi) {
      var inputs;
      inputs = midi.inputs();
      if (inputs.length) {
        inputs[0].onmidimessage = function(e) {
          var cmd, key, velocity, _ref1;
          _ref1 = e.data, cmd = _ref1[0], key = _ref1[1], velocity = _ref1[2];
          if (cmd === 144 && velocity > 0) {
            return dispatch.keydown({
              key: key,
              velocity: velocity,
              time: e.timeStamp,
              event: e
            });
          } else if (cmd === 128 || (cmd === 144 && velocity === 0)) {
            return dispatch.keyup({
              key: key,
              time: e.timeStamp,
              event: e
            });
          }
        };
        return dispatch.ready(dispatch, inputs[0]);
      } else {
        return dispatch.error(true, null);
      }
    }, function(err) {
      return dispatch.error(false, err);
    });
    nextId = (function() {
      var next;
      next = 0;
      return function(type) {
        return type + '.internal_' + next++;
      };
    })();
    untilTrue = function(type, fn) {
      var id;
      id = nextId(type);
      return dispatch.on(id, function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (fn.apply(null, args)) {
          return dispatch.on(id, null);
        }
      });
    };
    dispatch.waitForPress = function(key) {
      d('waiting for', key);
      return makePromise(function(defer) {
        return untilTrue('keydown', function(e) {
          d('checking for', key);
          if (e.key === key) {
            defer.resolve();
            return true;
          }
        });
      });
    };
    return dispatch;
  };

  initInstrument().on('keydown', function(e) {
    return d('Key down:', e.key, 'at speed', e.velocity);
  }).on('keyup', function(e) {
    return d('Key up:', e.key);
  }).on('error', function(instrumentMissing, err) {
    if (instrumentMissing) {
      return d('You have no MIDI keyboard.');
    } else {
      return d('Error initializing MIDI connection:', err);
    }
  }).on('ready', function(instr, input) {
    var ex;
    ex = [72, 74, 76, 77, 79, 77, 76, 74, 72];
    return ex.reduce(function(p, ks, i) {
      if (i) {
        return p.then(function() {
          return instr.waitForPress(ks);
        });
      } else {
        return p.fcall(instr.waitForPress, ks);
      }
    }, Q).then(function() {
      return d('finished!');
    });
  });

}).call(this);
